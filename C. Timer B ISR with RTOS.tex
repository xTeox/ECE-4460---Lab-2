\subsection{Timer B ISR with RTOS}

The main purpose of this procedure is to develop a RTOS that counts Timer B interrupts and displays the interrupt overhead.

\begin{code}[language=C, caption=blabla, label=amb]
#define TASK_STK_SIZE    512
#define OS_MAX_EVENTS      1
#define OS_MAX_TASKS       4
#define OS_TASK_STAT_EN    1
#define OS_TICKS_PER_SEC 128
#use "ucos2.lib"
void TaskStart(void *data);
void Task(void *data);
void InitTimerInt();
void Tmr_B_isr();
void UpdateStat();
void DispStr(int x, int y, char *s);
OS_EVENT *TimerSem;
int int_count;
int display_int_count;
int Timer_B_value;
void main (void)
{
    brdInit();
    OSInit();
    OSTaskCreate(TaskStart, (void *)0,
     TASK_STK_SIZE, 10);
    TimerSem = OSSemCreate(0);
    OSStart();
}
void TaskStart (void *data)
{
    OSTaskCreate(Task, (void *)0,
     TASK_STK_SIZE, 11);
    InitTimerInt();
    OSStatInit();
    DispStr(0, 12,
     "#Tasks          : xxxxx  CPU Usage: xxxxx %");
    DispStr(0, 13, "#Task switch/sec: xxxxx");
    DispStr(0, 14, "<-PRESS 'Q' TO QUIT->");
    for (;;) {
        UpdateStat();
        OSTimeDly(OS_TICKS_PER_SEC);
    }
}
nodebug void Task (void *data)
{
    auto UBYTE err;
    auto char display[128];
    auto char key;    
    display[0] = '\0';
    sprintf(display,
     "Number of Timer B interrupts: xxxxx (x1000)");
    DispStr(5, 2, display);
    display[0] = '\0';
    sprintf(display,
     "Timer B overhead: xxxxx  x(PCLK/16 cycles)");
    DispStr(5, 4, display);
    for (;;) {
        OSSemPend(TimerSem, 0, &err);
        display[0] = '\0';
        sprintf(display, "%5d", display_int_count);
        DispStr(35, 2, display);
        display[0] = '\0';
        sprintf(display, "%5d", Timer_B_value-350);
        DispStr(23, 4, display);
    }
}
void InitTimerInt()
{
    int_count = 0;
    display_int_count = 0;
    Timer_B_value = 0;
    SetVectIntern(0x0B, Tmr_B_isr);
    WrPortI(TBCR, &TBCRShadow, 0x09);
    WrPortI(TBM1R, NULL, 0x40);
    WrPortI(TBL1R, NULL, 0x5E);
    WrPortI(TBCSR, &TBCSRShadow, 0x03);
}
nodebug root interrupt void Tmr_B_isr()
{
    int TBCMR_status, TBCLR_status;
    char TMRB_status;
    TMRB_status = RdPortI(TBCSR);
    WrPortI(TBM1R, NULL, 0x40);
    WrPortI(TBL1R, NULL, 0x5E);
    int_count++;
    if (int_count == 1000) {
        display_int_count++;
        int_count = 0;
    }
    TBCLR_status = RdPortI(TBCLR);
    TBCMR_status = RdPortI(TBCMR);
    if (!(TBCLR_status & 0x80) &&
     ((TBCLR_status ^ RdPortI(TBCLR)) & 0x80))
        TBCMR_status--;
    OSIntExit();
}
void UpdateStat()
{
    char key, s[50];
    sprintf(s, "%5d", OSTaskCtr);
    DispStr(18, 12, s);
    #if OS_TASK_STAT_EN
        sprintf(s, "%5d", OSCPUUsage);
        DispStr(36, 12, s);
    #endif
    sprintf(s, "%5d", OSCtxSwCtr);
    DispStr(18, 13, s);
    OSCtxSwCtr = 0;
    if (kbhit()) {
        key = getchar();
        if (key == 0x71 || key == 0x51)
            exit(0);
    }
}
void DispStr(int x, int y, char *s)
{
   x += 0x20;
   y += 0x20;
   printf ("\x1B=%c%c%s", x, y, s);
}
\end{code}